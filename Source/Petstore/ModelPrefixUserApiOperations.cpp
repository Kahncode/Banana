/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "ModelPrefixUserApiOperations.h"
#include "PetstoreModule.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace CppNamespace 
{

/* TODO: use those to make things correct
FPlatformHttp::HtmlEncode
FPlatformHttp::UrlEncode
FPlatformHttp::GetMimeType*/

	FString ModelPrefixUserApi::CreateUserRequest::ComputePath() const
	{
		FString Path(TEXT("/user"));
		return Path;
	}

	void ModelPrefixUserApi::CreateUserRequest::SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const
	{
		HttpRequest->SetVerb(TEXT("POST"));

		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		Writer->WriteObjectStart();
		Writer->WriteIdentifierPrefix(TEXT("body")); WriteJsonValue(Writer, Body);
		Writer->WriteObjectEnd();
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}

	void ModelPrefixUserApi::CreateUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
	{
		Response::SetHttpResponseCode(InHttpResponseCode);
		switch ((int)InHttpResponseCode)
		{
		case 0:
		default:
			SetResponseString(TEXT("successful operation"));
			break;
		}
	}

	bool ModelPrefixUserApi::CreateUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
	{
		return true;
	}


	FString ModelPrefixUserApi::CreateUsersWithArrayInputRequest::ComputePath() const
	{
		FString Path(TEXT("/user/createWithArray"));
		return Path;
	}

	void ModelPrefixUserApi::CreateUsersWithArrayInputRequest::SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const
	{
		HttpRequest->SetVerb(TEXT("POST"));

		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		Writer->WriteObjectStart();
		Writer->WriteIdentifierPrefix(TEXT("body")); WriteJsonValue(Writer, Body);
		Writer->WriteObjectEnd();
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}

	void ModelPrefixUserApi::CreateUsersWithArrayInputResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
	{
		Response::SetHttpResponseCode(InHttpResponseCode);
		switch ((int)InHttpResponseCode)
		{
		case 0:
		default:
			SetResponseString(TEXT("successful operation"));
			break;
		}
	}

	bool ModelPrefixUserApi::CreateUsersWithArrayInputResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
	{
		return true;
	}


	FString ModelPrefixUserApi::CreateUsersWithListInputRequest::ComputePath() const
	{
		FString Path(TEXT("/user/createWithList"));
		return Path;
	}

	void ModelPrefixUserApi::CreateUsersWithListInputRequest::SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const
	{
		HttpRequest->SetVerb(TEXT("POST"));

		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		Writer->WriteObjectStart();
		Writer->WriteIdentifierPrefix(TEXT("body")); WriteJsonValue(Writer, Body);
		Writer->WriteObjectEnd();
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}

	void ModelPrefixUserApi::CreateUsersWithListInputResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
	{
		Response::SetHttpResponseCode(InHttpResponseCode);
		switch ((int)InHttpResponseCode)
		{
		case 0:
		default:
			SetResponseString(TEXT("successful operation"));
			break;
		}
	}

	bool ModelPrefixUserApi::CreateUsersWithListInputResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
	{
		return true;
	}


	FString ModelPrefixUserApi::DeleteUserRequest::ComputePath() const
	{
		TMap<FString, FStringFormatArg> PathParams = { 
    	{ TEXT("username"), ToStringFormatArg(Username) } };

		FString Path = FString::Format(TEXT("/user/{username}"), PathParams);
		
		return Path;
	}

	void ModelPrefixUserApi::DeleteUserRequest::SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const
	{
		HttpRequest->SetVerb(TEXT("DELETE"));
	}

	void ModelPrefixUserApi::DeleteUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
	{
		Response::SetHttpResponseCode(InHttpResponseCode);
		switch ((int)InHttpResponseCode)
		{
		case 400:
			SetResponseString(TEXT("Invalid username supplied"));
			break;
		case 404:
			SetResponseString(TEXT("User not found"));
			break;
		}
	}

	bool ModelPrefixUserApi::DeleteUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
	{
		return true;
	}


	FString ModelPrefixUserApi::GetUserByNameRequest::ComputePath() const
	{
		TMap<FString, FStringFormatArg> PathParams = { 
    	{ TEXT("username"), ToStringFormatArg(Username) } };

		FString Path = FString::Format(TEXT("/user/{username}"), PathParams);
		
		return Path;
	}

	void ModelPrefixUserApi::GetUserByNameRequest::SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const
	{
		HttpRequest->SetVerb(TEXT("GET"));
	}

	void ModelPrefixUserApi::GetUserByNameResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
	{
		Response::SetHttpResponseCode(InHttpResponseCode);
		switch ((int)InHttpResponseCode)
		{
		case 200:
		default:
			SetResponseString(TEXT("successful operation"));
			break;
		case 400:
			SetResponseString(TEXT("Invalid username supplied"));
			break;
		case 404:
			SetResponseString(TEXT("User not found"));
			break;
		}
	}

	bool ModelPrefixUserApi::GetUserByNameResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
	{
		return TryGetJsonValue(JsonValue, Content);
	}


	FString ModelPrefixUserApi::LoginUserRequest::ComputePath() const
	{
		FString Path(TEXT("/user/login"));
		TArray<FString> QueryParams;
		QueryParams.Add(FString(TEXT("username=")) + ToUrlString(Username));
		QueryParams.Add(FString(TEXT("password=")) + ToUrlString(Password));
		Path += TCHAR('?');
		Path += FString::Join(QueryParams, TEXT("&"));

		return Path;
	}

	void ModelPrefixUserApi::LoginUserRequest::SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const
	{
		HttpRequest->SetVerb(TEXT("GET"));
	}

	void ModelPrefixUserApi::LoginUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
	{
		Response::SetHttpResponseCode(InHttpResponseCode);
		switch ((int)InHttpResponseCode)
		{
		case 200:
		default:
			SetResponseString(TEXT("successful operation"));
			break;
		case 400:
			SetResponseString(TEXT("Invalid username/password supplied"));
			break;
		}
	}

	bool ModelPrefixUserApi::LoginUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
	{
		return TryGetJsonValue(JsonValue, Content);
	}


	FString ModelPrefixUserApi::LogoutUserRequest::ComputePath() const
	{
		FString Path(TEXT("/user/logout"));
		return Path;
	}

	void ModelPrefixUserApi::LogoutUserRequest::SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const
	{
		HttpRequest->SetVerb(TEXT("GET"));
	}

	void ModelPrefixUserApi::LogoutUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
	{
		Response::SetHttpResponseCode(InHttpResponseCode);
		switch ((int)InHttpResponseCode)
		{
		case 0:
		default:
			SetResponseString(TEXT("successful operation"));
			break;
		}
	}

	bool ModelPrefixUserApi::LogoutUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
	{
		return true;
	}


	FString ModelPrefixUserApi::UpdateUserRequest::ComputePath() const
	{
		TMap<FString, FStringFormatArg> PathParams = { 
    	{ TEXT("username"), ToStringFormatArg(Username) } };

		FString Path = FString::Format(TEXT("/user/{username}"), PathParams);
		
		return Path;
	}

	void ModelPrefixUserApi::UpdateUserRequest::SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const
	{
		HttpRequest->SetVerb(TEXT("PUT"));

		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		Writer->WriteObjectStart();
		Writer->WriteIdentifierPrefix(TEXT("body")); WriteJsonValue(Writer, Body);
		Writer->WriteObjectEnd();
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}

	void ModelPrefixUserApi::UpdateUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
	{
		Response::SetHttpResponseCode(InHttpResponseCode);
		switch ((int)InHttpResponseCode)
		{
		case 400:
			SetResponseString(TEXT("Invalid user supplied"));
			break;
		case 404:
			SetResponseString(TEXT("User not found"));
			break;
		}
	}

	bool ModelPrefixUserApi::UpdateUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
	{
		return true;
	}

}
