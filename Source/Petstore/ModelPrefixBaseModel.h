/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#pragma once

#include "Interfaces/IHttpResponse.h"
#include "Serialization/JsonWriter.h"
#include "Dom/JsonObject.h"

class FJsonObject;
class IHttpRequest;
class IHttpResponse;

typedef TSharedPtr<IHttpRequest> FHttpRequestPtr;
typedef TSharedPtr<IHttpResponse, ESPMode::ThreadSafe> FHttpResponsePtr;
//TODO: rename this into helpers or something like that
namespace CppNamespace 
{
	typedef TSharedRef<TJsonWriter<>> JsonWriter;

    class PETSTORE_API Model
	{ 
	public:
		virtual ~Model() {}
		virtual void WriteJson(JsonWriter& Writer) const = 0;
		virtual bool FromJson(const TSharedPtr<FJsonObject>& JsonObject) = 0;
	};

	class PETSTORE_API Request
	{
	public:
		virtual ~Request() {}
		virtual void SetupHttpRequest(const TSharedRef<IHttpRequest>& HttpRequest) const = 0;
		virtual FString ComputePath() const = 0;
	};

	class PETSTORE_API Response
	{
	public:
		virtual ~Response() {}
		virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonObject) = 0;
		void SetSuccessful(bool InSuccessful) { Successful = InSuccessful; }
		bool IsSuccessful() const { return Successful; }
		virtual void SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode);
		EHttpResponseCodes::Type GetHttpResponseCode() const { return ResponseCode; }
		void SetResponseString(const FString& InResponseString) { ResponseString = InResponseString; }
		const FString& GetResponseString() const { return ResponseString; }

	private:
		bool Successful;
		EHttpResponseCodes::Type ResponseCode;
		FString ResponseString;
	};

	//////////////////////////////////////////////////////////////////////////

	template<typename T, typename std::enable_if<!std::is_base_of<Model, T>::value, int>::type = 0>
	inline void WriteJsonValue(JsonWriter& Writer, const T& Value)
	{
		Writer->WriteValue(Value);
	}

	inline void WriteJsonValue(JsonWriter& Writer, const FDateTime& Value)
	{
		Writer->WriteValue(Value.ToIso8601());
	}

	inline void WriteJsonValue(JsonWriter& Writer, const Model& Value)
	{
		Value.WriteJson(Writer);
	}

	template<typename T>
	inline void WriteJsonValue(JsonWriter& Writer, const TArray<T>& Value)
	{
		Writer->WriteArrayStart();
		for (const auto& Element : Value)
		{
			WriteJsonValue(Writer, Element);
		}
		Writer->WriteArrayEnd();
	}

	template<typename T>
	inline void WriteJsonValue(JsonWriter& Writer, const TMap<FString, T>& Value)
	{
		Writer->WriteObjectStart();
		for (const auto& It : Value)
		{
			Writer->WriteIdentifierPrefix(It.Key);
			WriteJsonValue(Writer, It.Value);
		}
		Writer->WriteObjectEnd();
	}

	//////////////////////////////////////////////////////////////////////////

	template<typename T>
	inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, T& Value)
	{
		const TSharedPtr<FJsonValue> JsonValue = JsonObject->TryGetField(Key);
		if (JsonValue.IsValid() && !JsonValue->IsNull())
		{
			return TryGetJsonValue(JsonValue, Value);
		}
		return false;
	}

	template<typename T>
	inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TOptional<T>& OptionalValue)
	{
		if(JsonObject->HasField(Key))
		{
			T Value;
			if (TryGetJsonValue(JsonObject, Key, Value))
			{
				OptionalValue = Value;
				return true;
			}
			else
				return false;
		}
		return true; // Absence of optional value is not a parsing error
	}

	inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FString& Value)
	{
		FString TmpValue;
		if (JsonValue->TryGetString(TmpValue))
		{
			Value = TmpValue;
			return true;
		}
		else
			return false;
	}

	inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FDateTime& Value)
	{
		FString TmpValue;
		if (JsonValue->TryGetString(TmpValue))
			return FDateTime::Parse(TmpValue, Value);
		else
			return false;
	}

	inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, bool& Value)
	{
		bool TmpValue;
		if (JsonValue->TryGetBool(TmpValue))
		{
			Value = TmpValue;
			return true;
		}
		else
			return false;
	}

	template<typename T, typename std::enable_if<!std::is_base_of<Model, T>::value, int>::type = 0>
	inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
	{
		T TmpValue;
		if (JsonValue->TryGetNumber(TmpValue))
		{
			Value = TmpValue;
			return true;
		}
		else
			return false;
	}

	inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, Model& Value)
	{
		const TSharedPtr<FJsonObject>* Object;
		if (JsonValue->TryGetObject(Object))
			return Value.FromJson(*Object);
		else
			return false;
	}

	template<typename T>
	inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<T>& ArrayValue)
	{
		const TArray<TSharedPtr<FJsonValue>>* JsonArray;
		if (JsonValue->TryGetArray(JsonArray))
		{
			bool ParseSuccess = true;
			const int32 Count = JsonArray->Num();
			ArrayValue.Reset(Count);
			for (int i = 0; i < Count; i++)
			{
				T TmpValue;
				ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
				ArrayValue.Emplace(MoveTemp(TmpValue));
			}
			return ParseSuccess;
		}
		return false;
	}

	template<typename T>
	inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TMap<FString, T>& MapValue)
	{
		const TSharedPtr<FJsonObject>* Object;
		if (JsonValue->TryGetObject(Object))
		{
			MapValue.Reset();
			bool ParseSuccess = true;
			for (const auto& It : (*Object)->Values)
			{
				T TmpValue;
				ParseSuccess &= TryGetJsonValue(It.Value, TmpValue);
				MapValue.Emplace(It.Key, MoveTemp(TmpValue));
			}
			return ParseSuccess;
		}
		return false;
	}

	//////////////////////////////////////////////////////////////////////////

	template<typename T>
	inline FStringFormatArg ToStringFormatArg(const T& Value)
	{
		return FStringFormatArg(Value);
	}

	inline FStringFormatArg ToStringFormatArg(const FDateTime& Value)
	{
		return FStringFormatArg(Value.ToIso8601());
	}

	template<typename T>
	inline FString ToString(const T& Value)
	{
		return FString::Format(TEXT("{0}"), { ToStringFormatArg(Value) });
	}

	inline FString ToString(const FString& Value)
	{
		return Value;
	}

	template<typename T>
	inline FString ToUrlString(const T& Value)
	{
		return FPlatformHttp::UrlEncode(ToString(Value));
	}

	template<typename T>
	inline FString CollectionToUrlString(const TArray<T>& Collection, const TCHAR* Separator)
	{
		FString Output;
		if(Collection.Num() == 0)
			return Output;

		Output += ToUrlString(Collection[0]);
		for(int i = 1; i < Collection.Num(); i++)
		{
			Output += FString::Format(TEXT("{0}{1}"), { Separator, *ToUrlString(Collection[i]) });
		}
		return Output;
	}

	template<typename T>
	inline FString CollectionToUrlString_csv(const TArray<T>& Collection, const TCHAR* BaseName)
	{
		return CollectionToUrlString(Collection, TEXT(","));
	}

	template<typename T>
	inline FString CollectionToUrlString_ssv(const TArray<T>& Collection, const TCHAR* BaseName)
	{
		return CollectionToUrlString(Collection, TEXT(" "));
	}

	template<typename T>
	inline FString CollectionToUrlString_tsv(const TArray<T>& Collection, const TCHAR* BaseName)
	{
		return CollectionToUrlString(Collection, TEXT("\t"));
	}

	template<typename T>
	inline FString CollectionToUrlString_pipes(const TArray<T>& Collection, const TCHAR* BaseName)
	{
		return CollectionToUrlString(Collection, TEXT("|"));
	}

	template<typename T>
	inline FString CollectionToUrlString_multi(const TArray<T>& Collection, const TCHAR* BaseName)
	{
		FString Output;
		if(Collection.Num() == 0)
			return Output;

		Output += FString::Format(TEXT("{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(Collection[i]) });
		for(int i = 1; i < Collection.Num(); i++)
		{
			Output += FString::Format(TEXT("&{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(Collection[i]) });
		}
		return Output;
	}



}
